// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Node{
    int isObstacle;
    float3 position;

    int gridX;
    int gridY;

    int gCost;
    int hCost;
    int fCost; // gCost + hCost

    int parentX;
    int parentY;
};

RWStructuredBuffer<Node> inputBuffer;
RWStructuredBuffer<int> integerOutputBuffer;

int isNeighbourInClosedSet;
int isNeighbourInOpeSet;

int GetDistance(Node nodeA, Node nodeB){
    int distX = abs(nodeA.gridX - nodeB.gridX);
    int distY = abs(nodeA.gridY - nodeB.gridY);

    if(distX > distY){
        return 14 * (distY) + 10 * (distX - distY);
    }
    return 14 * (distX) + 10 * (distY - distX);
}

int OpenSetAddControl(){ // return => -1: continue, 0: don't add open set, 1: add open set
    // inputBuffer => 0: neighbour, 1: current, 2: endNode
    if(inputBuffer[0].isObstacle == 1 || isNeighbourInClosedSet == 1){
        return -1; // continue
    }

    int newMovementCostToNeighbour = inputBuffer[1].gCost + GetDistance(inputBuffer[1], inputBuffer[0]);
    if(newMovementCostToNeighbour < inputBuffer[0].gCost || isNeighbourInOpeSet == 0){
        inputBuffer[0].gCost = newMovementCostToNeighbour;
        inputBuffer[0].hCost = GetDistance(inputBuffer[0], inputBuffer[2]);
        inputBuffer[0].parentX = inputBuffer[1].gridX;
        inputBuffer[0].parentY = inputBuffer[1].gridY;
        if(isNeighbourInOpeSet == 0){
            return 1;
        }
    }
    return 0;
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    integerOutputBuffer[0] = OpenSetAddControl();
}
